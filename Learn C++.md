## Learn C++ 

### 一、C 到 C++

#### 1.namespace

namespace 是 c++ 的关键字，表示一类变量、函数、类、typedef、#define 等符号的命名空间。

Syntax 

```c++
namespace name{
    //variables, functions, classes
}
```

使用变量时要指出命名空间，使用 `::` (域解析操作符)，例如

```c++
Moo::display();
```

除了使用域解析符，还可以使用 `using` 关键字。`using` 的意思是，在声明之后的程序中若出现未指明空间的符号，默认采用声明的命名空间中的符号。

Syntax 

```c++
using namespace Moo;
display();
look = 1;
Else::look = 2;
//也可以单独声明一个变量
using Else::take;
take = true;
Moo::take = false;
```

在 main() 函数中声明命名空间 std，它的作用范围就位于 main() 函数内部，如果在其他函数中又用到了 std，就需要重新声明。如果希望在所有函数中都使用命名空间 std，可以将它声明在全局范围中。

```c++
#include <iostream>
using namespace std; // statement
//...
```

#### 2.头文件

旧版 c++ 使用的库 iostream.h fstream.h 在新版中为 iostream fstream ；而 c 中的库 stdio.h stdlib.h 变成了 cstdio cstdlib 

对于新版头文件，所有符号都位于 namespace std 中，需要声明 std ；对于 旧版，没有命名空间，所有符号都是全局的。

严格的 C++ 标准要求声明 std

#### 3.输入输出

需要包含头文件 iostream 

cin 和 cout 是内置对象，使用 cin 时，要紧跟流插入符 >>，使用 cout 时，要紧跟流提取符 << 

```c++
int x;
cin>>x;
```

上述代码表示从标准输入中提取一个整型数赋值给x，若读取到非整型，则会强制转化。

#### 4.new 和 delete 运算符

new 用来动态分配内存， delete 用来释放内存，与 c 语言中的 malloc() 和 free() 一样，二者一般成对出现。此外要分配连续内存还可以使用 new [] 和 delete[] 

Syntax

```c++
int *p = new int;
delete p;
int *p = new int[10];
delete[] p;
```

####  5.内联函数

在函数定义前加上 inline 表示内联函数，相当于在函数调用处将函数代码替换展开，以减少调用开销。一般将简单的函数设为内联函数，因为复杂函数的开销大部分在函数执行上而不是函数调用。

Syntax

```c++
inline void switch(int *a, int *b) {
//...
}
```

#### 6.函数默认参数

默认参数是函数调用中省略了实际参数时默认使用的值。默认参数除了使用数值常量指定，也可以使用表达式指定。

Syntax

```c++
float x = 5.0;
void func1(int a, float b = 1.2 + x, string c = "defalut"){
//...
}
```

C++规定，默认参数只能放在形参列表的最后，而且一旦为某个形参指定了默认值，那么它后面的所有形参都必须有默认值。

#### 7.函数重载

重载的规则：

- 函数名称必须相同。

- 参数列表必须不同（个数不同、类型不同、参数排列顺序不同等）。

- 函数的返回类型可以相同也可以不相同。

- 仅仅返回类型不同不足以成为函数的重载。


---

### 二、类和对象

#### 1.类的定义

类的定义最后有一个分号，不能省略，例如

```c++
class Vehicle{
public:
	string id;
	
	void run(){
	//...
	}
};  //不能省略
```

#### 2.创建对象与访问成员

Syntax

```c++
Vehicle bens;
class Vehicle bmw; //同样正确
```

使用 . 来访问成员变量和成员函数，例如

```c++
Vehicle bmw;
bmw.id = "666666";
bmw.run();
```

#### 3.使用对象指针

指针在 C++ 中广泛使用，用法和 C 中相似。

```c++
Vehicle bens;
Vehicle *pbens = &bens;
```

也可以在堆上创建对象，这个时候就需要使用`new`关键字。在栈上创造的对象不必要使用指针指向，但是在堆上的对象必须使用指针指向。此外，堆上的内存是动态分配的，需由程序员手动管理，即`new`和`delete`成对出现。

#### 4.成员变量和成员函数

在类体中直接定义函数时，不需要在函数名前面加上类名但当成员函数定义在类外时，就必须在函数名前面加上类名予以限定。`::`被称为域解析符，用来连接类名和函数名，指明当前函数属于哪个类。

在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会。如果你既希望将函数定义在类体外部，又希望它是内联函数，那么可以在定义函数时加 inline 关键字，但必须将类的定义和成员函数的定义都放在同一个头文件中（或者同一个源文件中）。

#### 5.访问权限

`C++`通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员。

类的声明和成员函数的定义都是类定义的一部分，在实际开发中，我们通常将类的声明放在头文件中，而将成员函数的定义放在源文件中。

成员变量大都以`m_`开头，这是约定成俗的写法，不是语法规定的内容。以`m_`开头既可以一眼看出这是成员变量，又可以和成员函数中的形参名字区分开。

声明为 private 的成员和声明为 public 的成员的次序任意，既可以先出现 private 部分，也可以先出现 public 部分。如果既不写 private 也不写 public，就默认为 private。private 和 public 可以分别出现多次。

#### 6.构造函数

在`C++`中，有一种特殊的成员函数，它的名字和类名相同，没有返回值，不需要用户显式调用（用户也不能调用），而是在创建对象时自动执行。这种特殊的成员函数就是构造函（Constructor），构造函数不能有返回值。构造函数可以重载。

类也可以没有构造函数（默认构造器），但一但定义过后在创建对象时就必须显示调用。调用没有参数的构造函数也可以省略括号。在栈上创建对象可以写作`Student stu()`或`Student stu`，在堆上创建对象可以写作`Student *pstu = new Student()`或`Student *pstu = new Student`。

构造函数初始化列表：定义构造函数时并没有在函数体中对成员变量一一赋值，而是在函数首部与函数体之间添加了一个冒号`:`，后面紧跟`m_name(name), m_age(age), m_score(score)`语句，比起写在函数体中更加简洁。

Syntax

```c++
Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){
    //TODO:
}
```

注意，在初始化列表中，成员变量的赋值顺序仅由声明顺序决定，而无关构造化列表的顺序。

构造函数初始化列表还有一个很重要的作用，那就是初始化 const 成员变量。**初始化 const 成员变量的唯一方法就是使用初始化列表**。

```c++
class VLA{ //模拟变长数组
private:
    const int m_len;
    int *m_arr;
public:
    VLA(int len);
};
//必须使用初始化列表来初始化 m_len
VLA::VLA(int len): m_len(len){
    m_arr = new int[len];
}
```

#### 7.析构函数

析构函数（Destructor）也是一种特殊的成员函数，没有返回值，不需要程序员显式调用（程序员也没法显式调用），而是在销毁对象时自动执行。构造函数的名字和类名相同，而析构函数的名字是在类名前面加一个`~`符号。

析构函数没有参数，不能重载，如果没定义析构函数，会使用默认函数。

```c++
VLA::~VLA(){
    delete[] m_arr;  //释放内存
}
```

#### 8. this关键字

this 是 `C++`中的一个关键字，也是一个 const指针，它指向当前对象，通过它可以访问当前对象的所有成员。

几点注意：

- this 是 const 指针，它的值是不能被修改的，一切企图修改该指针的操作，如赋值、递增、递减等都是不允许的。
- this 只能在成员函数内部使用，用在其他地方没有意义，也是非法的。
- 只有当对象被创建后 this 才有意义，因此不能在 static 成员函数中使用（后续会讲到 static 成员）。

**this 实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给 this。不过 this 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。**

#### 9.static静态变量&静态函数

static 成员变量必须在类声明的外部初始化，其他函数使用、改变static变量时必须提前初始化，具体形式为：

```c++
type class::name = value;
```

**static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的 static 成员变量不能使用。static变量可以通过this指针来指示。**

静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。

#### 10.const常变量&常函数&常对象

初始化 const 成员变量只有一种方法，就是通过构造函数的初始化列表。const变量可以用this来指示。

const 成员函数可以使用类中的所有成员变量，但是**不能修改**它们的值，这种措施主要还是为了保护数据而设置的。const 成员函数也称为常成员函数。

常成员函数需要在声明和定义的时候在**函数头部的结尾**加上 const 关键字，例如

```
 char *getname() const;
 int getage() const;
```

最后再来区分一下 const 的位置：

- 函数开头的 const 用来修饰函数的返回值，表示返回值是 const 类型，也就是不能被修改，例如`const char * getname()`。
- 函数头部的结尾加上 const 表示常成员函数，这种函数只能读取成员变量的值，而不能修改成员变量的值，例如`char * getname() const`。

const 也可以用来修饰对象，称为常对象。一旦将对象定义为常对象之后，就只能调用类的 const 成员（包括 const 成员变量和 const 成员函数）了。

定义常对象的语法和定义常量的语法类似：

```c++
const class  object(params);
class const object(params);
```

当然你也可以定义 const [指针](http://c.biancheng.net/c/80/)：

```c++
const class *p = new class(params);
class const *p = new class(params);
```

#### 11.友元函数&友元类

在当前类以外定义的、不属于当前类的函数也可以在类中声明，但要在前面加 friend 关键字，这样就构成了友元函数。友元函数可以是不属于任何类的非成员函数，也可以是其他类的成员函数。

借助友元（friend），可以使得其他类中的成员函数以及全局范围内的函数访问当前类的所有成员。

友元函数既可以声明在类的private后，也可声明在public后。友元函数既可以是不属于任何类的函数，也可以是某个类的函数，后者需要在声明时指出具体类，例如

```c++
friend void Student::show(Address *addr);
```

不仅可以将一个函数声明为一个类的“朋友”，还可以将整个类声明为另一个类的“朋友”，这就是友元类。友元类中的所有成员函数都是另外一个类的友元函数。

在类A中声明`friend class B;`的含义是类B可以访问类A中的所有成员。同理在类A中声明的函数`friend int show(A *pA);`的含义是show函数可以访问leiA的所有成员。

关于友元，有两点需要说明：

- 友元的关系是单向的而不是双向的。如果声明了类 B 是类 A 的友元类，不等于类 A 是类 B 的友元类，类 A 中的成员函数不能访问类 B 中的 private 成员。
- 友元的关系不能传递。如果类 B 是类 A 的友元类，类 C 是类 B 的友元类，不等于类 C 是类 A 的友元类。
- 除非有必要，一般不建议把整个类声明为友元类，而只将某些成员函数声明为友元函数，这样更安全一些。

#### 12.struct & class

C++ 中保留了C语言的 struct 关键字，并且加以扩充。在C语言中，struct 只能包含成员变量，不能包含成员函数。而在C++中，struct 类似于 class，既可以包含成员变量，又可以包含成员函数。

C++中的 struct 和 class 基本是通用的，唯有几个细节不同：

- 使用 class 时，类中的成员默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的。
- class 继承默认是 private 继承，而 struct 继承默认是 public 继承。
- class 可以使用模板，而 struct 不能。

#### 13.string 类

C++中的String类与C中的string类型最大不同之一是字符串尾没有\0，字符串长度就是字符串的真实长度。（长度用字符串类的`length()`函数）

C++中的String类可以用等号赋值。

String类提供`c_str()`函数将String类对象转换为C中的string数据类型。例如

```c++
string path = "D:\\demo.txt";
FILE *fp = fopen(path.c_str(), "rt"); //fopen必须使用C风格的字符串
```

string 字符串也可以像C风格的字符串一样按照下标来访问其中的每一个字符，并仍从0开始计数。

可以使用`+`或`+=`运算符来直接拼接字符串。



insert() 函数可以在 string 字符串中指定的位置插入另一个字符串，它的一种原型为：

```c++
string& insert (size_t pos, const string& str);
```

pos 表示要插入的位置，也就是下标；str 表示要插入的字符串，它可以是 string 字符串，也可以是C风格的字符串。



erase() 函数可以删除 string 中的一个子字符串。它的一种原型为：

```c++
string& erase (size_t pos = 0, size_t len = npos);
```

pos 表示要删除的子字符串的起始下标，len 表示要删除子字符串的长度。如果不指明 len 的话，那么直接删除从 pos 到字符串结束处的所有字符（此时 len = str.length - pos）。待删除字符串最多只能删除到字符串结尾。



substr() 函数用于从 string 字符串中提取子字符串，它的原型为：

```c++
string substr (size_t pos = 0, size_t len = npos) const;
```

pos 为要提取的子字符串的起始下标，len 为要提取的子字符串的长度。



find() 函数用于在 string 字符串中查找子字符串出现的位置，它其中的两种原型为：

```c++
size_t find (const string& str, size_t pos = 0) const;
size_t find (const char* s, size_t pos = 0) const;
```

第一个参数为待查找的子字符串，它可以是 string 字符串，也可以是C风格的字符串。第二个参数为开始查找的位置（下标）；如果不指明，则从第0个字符开始查找。



rfind() 和 find() 很类似，同样是在字符串中查找子字符串，不同的是 find() 函数从第二个参数开始往后查找，而 rfind() 函数则最多查找到第二个参数处，如果到了第二个参数所指定的下标还没有找到子字符串，则返回一个无穷大值4294967295。



find_first_of() 函数用于查找子字符串和字符串共同具有的字符在字符串中首次出现的位置。

---

### 三、引用

#### 1.基本定义

在 C/C++ 中，我们将 char、int、float 等由语言本身支持的类型称为基本类型，将数组、结构体、类（对象）等由基本类型组合而成的类型称为聚合类型（在讲解结构体时也曾使用复杂类型、构造类型这两种说法）。

引用（Reference）是 C++ 相对于C语言的又一个扩充。引用可以看做是数据的一个别名，通过这个别名和原来的名字都能够找到这份数据。引用类似于 Windows 中的快捷方式，一个可执行程序可以有多个快捷方式，通过这些快捷方式和可执行程序本身都能够运行程序。

引用的定义方式类似于指针，只是用`&`取代了`*`，语法格式为：

```c++
type &name = data; //用对象初始化引用
```

type 是被引用的数据的类型，name 是引用的名称，data 是被引用的数据。引用必须在定义的同时初始化，并且以后也要从一而终，不能再引用其它数据，这有点类似于常量（const 变量）。

Syntax

```c++
#include <iostream>
using namespace std;
int main() {
    int a = 99;
    int &r = a;
    cout << a << ", " << r << endl;
    cout << &a << ", " << &r << endl;
    return 0;
}
//output
//99, 99
//0x28ff44, 0x28ff44
```

本例中，变量 r 就是变量 a 的引用，它们用来指代同一份数据；也可以说变量 r 是变量 a 的另一个名字。从输出结果可以看出，a 和 r 的地址一样，都是`0x28ff44`；或者说地址为`0x28ff44`的内存有两个名字，a 和 r，想要访问该内存上的数据时，使用哪个名字都行。

注意：

- 引用在定义时需要添加`&`，在使用时不能添加`&`，使用时添加`&`表示取地址。

- **不能建立数组的引用**。因为数组是一个由若干个元素所组成的集合，所以无法建立一个数组的别名。

- 引用声明完毕后，相当于**目标变量名有两个名称**，即该**目标原名称**和**引用名**，且不能再把该引用名作为其他变量名的别名。

  　　 

  ```C++
  ra=1; //等价于 a=1;
  ```

  



#### 2.引用作为函数参数

在定义或声明函数时，我们可以将函数的形参指定为引用的形式，这样在调用函数时就会将实参和形参绑定在一起，让它们都指代同一份数据。如此一来，如果在函数体中修改了形参的数据，那么实参的数据也会被修改，从而拥有“在函数内部影响函数外部数据”的效果。

```c++
//传递指针
void swap2(int *p1, int *p2) {
    int temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}
//按引用传参
void swap3(int &r1, int &r2) {
    int temp = r1; //创造一个新对象，其值等于r1引用指向的对象的值
    r1 = r2; //引用r1指向引用r2
    r2 = temp; //引用r2指向temp
}
```

从以上代码的编写中可以发现，按引用传参在使用形式上比指针更加直观。在以后的 C++ 编程中，我鼓励读者大量使用引用，它一般可以代替指针（当然指针在C++中也不可或缺），C++ 标准库也是这样做的。

#### 3.引用作为函数返回值

引用除了可以作为函数形参，还可以作为函数返回值，例如：

```c++
#include <iostream>
using namespace std;
int &plus10(int &r) {
    r += 10;
    return r;
}
int main() {
    int num1 = 10;
    int num2 = plus10(num1);//需要传入一个引用，传入的形参r即是num1的一个引用
    //同时返回一个引用指向的对象的值给num2赋值
    cout << num1 << " " << num2 << endl;
    return 0;
}
//output
//20 20
```

在将引用作为函数返回值时应该注意一个小问题，就是不能返回局部数据（例如局部变量、局部对象、局部数组等）的引用，（例如下第四种情况）因为当函数调用完成后局部数据就会被销毁，有可能在下次使用时数据就不存在了，C++ 编译器检测到该行为时也会给出警告。

此外，引用不能指向一个局部变量的返回值，例如下第二种情况

```c++

#include <iostream.h>
float temp; //定义全局变量temp
float fn1(float r); //声明函数fn1
float &fn2(float r); //声明函数fn2
float fn1(float r) //定义函数fn1，它以返回值的方法返回函数值
{
　temp=(float)(r*r*3.14);
　return temp;
}
float &fn2(float r) //定义函数fn2，它以引用方式返回函数值
{
　temp=(float)(r*r*3.14);
　return temp;
}
void main() //主函数
{
　float a=fn1(10.0); //第1种情况，系统生成要返回值的副本（即临时变量）
　float &b=fn1(10.0); //第2种情况，可能会出错（不同 C++系统有不同规定）
　//不能从被调函数中返回一个临时变量或局部变量的引用
　float c=fn2(10.0); //第3种情况，系统不生成返回值的副本
　//可以从被调函数中返回一个全局变量的引用
　float &d=fn2(10.0); //第4种情况，系统不生成返回值的副本
　//可以从被调函数中返回一个全局变量的引用
　cout<<a<<c<<d;
}

```

#### 4.常引用

常引用声明方式：const 类型标识符 &引用名=目标变量名；

用这种方式声明的引用，**不能通过引用对目标变量的值进行修改**,从而使引用的目标成为const，达到了引用的安全性。例如

```c++
int a ;
const int &ra=a;
ra=1; //错误
a=1; //正确
```

假设有如下函数声明：

```
string foo( );
void bar(string & s);
```

那么下面的表达式将是非法的：

```
bar(foo( ));
bar("hello world");
```

原因在于foo( )和"hello world"串都会产生一个临时对象，而在C++中，这些临时对象都是const类型的。因此上面的表达式就是***\*试图将一个const类型的对象转换为非const类型\****，这是***\*非法\****的。

引用型参数应该在能被定义为const的情况下，尽量定义为const 。

---

### 四、继承和派生

#### 1.定义

**继承（Inheritance）**可以理解为一个类从另一个类获取成员变量和成员函数的过程。例如类 B 继承于类 A，那么 B 就拥有 A 的成员变量和成员函数。

在C++中，**派生（Derive）**和继承是一个概念，只是站的角度不同。继承是儿子接收父亲的产业，派生是父亲把产业传承给儿子。

被继承的类称为父类或基类，继承的类称为子类或派生类。“子类”和“父类”通常放在一起称呼，“基类”和“派生类”通常放在一起称呼。

注意：

- 一个类可以**派生自**多个类，这意味着，它可以从多个基类继承数据和函数。
- 派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。
- 一个派生类继承了所有的基类方法，但下列情况除外：
  - 基类的构造函数、析构函数和拷贝构造函数。
  - 基类的重载运算符。
  - 基类的友元函数。

下面我们定义一个基类 People，然后由此派生出 Student 类：

```c++
#include<iostream>
using namespace std;
//基类 Pelple
class People{
public:
    void setname(char *name);
    void setage(int age);
    char *getname();
    int getage();
private:
    char *m_name;
    int m_age;
};
void People::setname(char *name){ m_name = name; }
void People::setage(int age){ m_age = age; }
char* People::getname(){ return m_name; }
int People::getage(){ return m_age;}
//派生类 Student
class Student: public People{
public:
    void setscore(float score);
    float getscore();
private:
    float m_score;
};
void Student::setscore(float score){ m_score = score; }
float Student::getscore(){ return m_score; }
int main(){
    Student stu;
    stu.setname("小明");
    stu.setage(16);
    stu.setscore(95.5f);
    cout<<stu.getname()<<"的年龄是 "<<stu.getage()<<"，成绩是 "<<stu.getscore()<<endl;
    return 0;
}
```

#### 2.三种继承类型

继承的一般语法为：

```c++
class 派生类名:［继承方式］ 基类名{
    派生类新增加的成员
};
```

继承方式包括 public（公有的）、private（私有的）和 protected（受保护的），此项是可选的，如果不写，那么默认为 private。

我们几乎不使用 **protected** 或 **private** 继承，通常使用 **public** 继承。当使用不同类型的继承时，遵循以下几个规则：

- **公有继承（public）：**当一个类派生自**公有**基类时，基类的**公有**成员也是派生类的**公有**成员，基类的**保护**成员也是派生类的**保护**成员，基类的**私有**成员不能直接被派生类访问，但是可以通过调用基类的**公有**和**保护**成员来访问。
- **保护继承（protected）：** 当一个类派生自**保护**基类时，基类的**公有**和**保护**成员将成为派生类的**保护**成员。
- **私有继承（private）：**当一个类派生自**私有**基类时，基类的**公有**和**保护**成员将成为派生类的**私有**成员。

#### 3.改变访问权限

使用 using 关键字可以改变基类成员在派生类中的访问权限，例如将 public 改为 private、将 protected 改为 public。

注意：using **只能改变**基类中 **public** 和 **protected** 成员的访问权限，不能改变 private 成员的访问权限，因为基类中 private 成员在派生类中是不可见的，根本不能使用，所以基类中的 private 成员在派生类中无论如何都不能访问。

Syntax

```c++
#include<iostream>
using namespace std;
//基类People
class People {
public:
    void show();
protected:
    char *m_name;
    int m_age;
};

//派生类Student
class Student : public People {
public:
    void learning();
public:
    using People::m_name;  //将protected改为public
    using People::m_age;  //将protected改为public
    float m_score;
private:
    using People::show;  //将public改为private
};
```

#### 4.成员名字遮蔽&函数不重载

如果派生类中的成员（包括成员变量和成员函数）和基类中的成员重名，那么就会遮蔽从基类继承过来的成员。所谓遮蔽，就是在派生类中使用该成员（包括在定义派生类时使用，也包括通过派生类对象访问该成员）时，实际上使用的是派生类新增的成员，而不是从基类继承来的。

基类成员和派生类成员的名字一样时会造成遮蔽，这句话对于成员变量很好理解，对于成员函数要引起注意，不管函数的参数如何，只要名字一样就会造成遮蔽。换句话说，基类成员函数和派生类成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样。

#### 5.构造函数&析构函数

注意：

- 类的构造函数不能被继承。
- 在派生类的构造函数中可以调用基类的构造函数。
- 基类构造函数的调用只能放在函数头部，不能放在函数体中。
- `Student::Student(char *name, int age, float score): People(name, age), m_score(score){/*...*/}`  等同于`Student::Student(char *name, int age, float score): m_score(score), People(name, age){ /*...*/}` 即初始化列表和基类构造函数位置可替换。
- 在多层次继承中，派生类构造函数中只能调用**直接基类**的构造函数，不能调用间接基类的。



注意：

- 销毁派生类对象时，析构函数的执行顺序和继承顺序相反，即先执行派生类析构函数，再执行基类析构函数。

---

### 五、多继承

#### 1.定义

C++也支持**多继承（Multiple Inheritance）**，即一个派生类可以有两个或多个基类。

多继承的语法也很简单，将多个基类用逗号隔开即可。例如已声明了类A、类B和类C，那么可以这样来声明派生类D：

```c++
class D: public A, private B, protected C{
    //类D新增加的成员
}
```

D 是多继承形式的派生类，它以公有的方式继承 A 类，以私有的方式继承 B 类，以保护的方式继承 C 类。D 根据不同的继承方式获取 A、B、C 中的成员，确定它们在派生类中的访问权限。

#### 2.多继承下的构造函数

多继承形式下的构造函数和单继承形式基本相同，只是要在派生类的构造函数中调用多个基类的构造函数。以上面的 A、B、C、D 类为例，D 类构造函数的写法为：

```c++
D(形参列表): A(实参列表), B(实参列表), C(实参列表){
    //其他操作
}
```

基类构造函数的调用顺序和和它们在派生类构造函数中出现的顺序无关，而是和声明派生类时基类出现的顺序（类第一行）相同。

#### 3.命名冲突

当两个或多个基类中有同名的成员时，如果直接访问该成员，就会产生命名冲突，编译器不知道使用哪个基类的成员。这个时候需要在成员名字前面加上类名和域解析符`::`，以显式地指明到底使用哪个类的成员，消除二义性。

#### 4.菱形继承

![菱形继承](http://c.biancheng.net/uploads/allimg/200629/1-2006291I602320.png)

类 A 派生出类 B 和类 C，类 D 继承自类 B 和类 C，这个时候类 A 中的成员变量和成员函数继承到类 D 中变成了两份，一份来自 A-->B-->D 这条路径，另一份来自 A-->C-->D 这条路径。

假如类 A 有一个成员变量 m_a，那么在类 D 中直接访问 m_a 就会产生歧义，编译器不知道它究竟来自 A -->B-->D 这条路径，还是来自 A-->C-->D 这条路径。

为了消除歧义，我们可以在 m_a 的前面指明它具体来自哪个类：

```c++
 B::m_a = a;
 C::m_a = a;
```

#### 5.虚继承

为了解决多继承时的命名冲突和冗余数据问题，[C++](http://c.biancheng.net/cplus/) 提出了虚继承，使得在派生类中只保留一份间接基类的成员。

在继承方式前面加上 virtual 关键字就是虚继承，请看下面的例子：

```c++
//间接基类A
class A{
protected:
    int m_a;
};
//直接基类B
class B: virtual public A{  //虚继承
protected:
    int m_b;
};
//直接基类C
class C: virtual public A{  //虚继承
protected:
    int m_c;
};
//派生类D
class D: public B, public C{ //一般继承
public:
    void seta(int a){ m_a = a; }  //正确 若B、C为一般继承，此处会有错误
    void setb(int b){ m_b = b; }  //正确
    void setc(int c){ m_c = c; }  //正确
    void setd(int d){ m_d = d; }  //正确
private:
    int m_d;
};
int main(){
    D d;
    return 0;
}
```

虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class），本例中的 A 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。

![菱形继承和虚继承](http://c.biancheng.net/uploads/allimg/200629/1-2006291J3551E.png)

观察这个新的继承体系，我们会发现虚继承的一个不太直观的特征：**必须在虚派生的真实需求出现前就已经完成虚派生的操作。**在上图中，当定义 D 类时才出现了对虚派生的需求，但是如果 B 类和 C 类不是从 A 类虚派生得到的，那么 D 类还是会保留 A 类的两份成员。

**换个角度讲，虚派生只影响从指定了虚基类的派生类中进一步派生出来的类，它不会影响派生类本身。**

注意：

- 不提倡在程序中使用多继承，只有在比较简单和不易出现二义性的情况或实在必要时才使用多继承，能用单一继承解决的问题就不要使用多继承。

**虚继承的构造函数**：在虚继承中，虚基类是由最终的派生类初始化的，换句话说，最终派生类的构造函数**必须要调用**虚基类的构造函数。对最终的派生类来说，虚基类是间接基类，而不是直接基类。这跟普通继承不同，在普通继承中，派生类构造函数中只能调用直接基类的构造函数，**不能**调用间接基类的。

#### 6.向上转型

类其实也是一种数据类型，也可以发生数据类型转换，不过这种转换只有在基类和派生类之间才有意义，并且只能将派生类赋值给基类，包括将派生类对象赋值给基类对象、将派生类[指针](http://c.biancheng.net/c/80/)赋值给基类指针、将派生类引用赋值给基类引用，这在 C++ 中称为向上转型（Upcasting）。相应地，将基类赋值给派生类称为向下转型（Downcasting）。

向上转型非常安全，可以由编译器自动完成；向下转型有风险，需要程序员手动干预。

赋值的本质是将现有的数据写入已分配好的内存中，对象的内存只包含了成员变量，所以对象之间的赋值是成员变量的赋值，成员函数不存在赋值问题。

![img](http://c.biancheng.net/uploads/allimg/190214/1G45K0C-0.png)

**派生类指针转型为基类指针**：将派生类指针赋值给基类指针时，通过基类指针只能使用派生类的成员**变量**，但不能使用派生类的成员**函数**。这是因为在向上转型中，隐式指针this发生了变化，指向了派生类对象，所以在基类函数中调用的是派生类的成员变量。例如，

```c++
class A {/*...*/};
class B:public A{/*...*/};
A *pa = new A(/*...*/);
B *pb = new B(/*...*/);
pa = pb;
pa->func(/*...*/); //调用A类的成员函数func，使用B类的成员变量
```

编译器虽然通过指针的指向来访问成员变量，但是却不通过指针的指向来访问成员函数：编译器通过指针的类型来访问成员函数。对于 pa，它的类型是 A，不管它指向哪个对象，使用的都是 A 类的成员函数。

**派生类引用转型为基类引用**：引用在本质上是通过指针的方式实现的。引用同样使用了派生类对象的成员变量，但是却没有使用派生类的成员函数。

最后需要注意的是，向上转型后通过基类的对象、指针、引用只能访问从基类继承过去的成员（包括成员变量和成员函数），不能访问派生类新增的成员。

---

### 六、多态

#### 1.定义

**多态（polymorphism）**指的是同一名字的事物可以完成不同的功能。多态可以分为编译时的多态和运行时的多态。前者主要是指函数的重载（包括运算符的重载）、对重载函数的调用，在编译时就能根据实参确定应该调用哪个函数，因此叫编译时的多态；而后者则和继承、虚函数等概念有关，是本章要讲述的内容。本教程后面提及的多态都是指运行时的多态。

一般来说，通过基类指针只能访问派生类的成员变量，但是不能访问派生类的成员函数。为了消除这种尴尬，让基类指针能够访问派生类的成员函数，C++增加了**虚函数（Virtual Function）**。使用虚函数非常简单，只需要在函数声明前面增加 virtual 关键字。

只要基类和派生类均声明了同样名称的虚函数，则基类可调用派生类的虚函数。

有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。

没有虚函数，指针类型为什么类，就只能使用该类的函数。

换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为**多态**。

Syntax

```c++
#include <iostream>
using namespace std;
//基类People
class People{
public:
    People(char *name, int age);
    virtual void display();  //声明为虚函数
protected:
    char *m_name;
    int m_age;
};
People::People(char *name, int age): m_name(name), m_age(age){}
void People::display(){
    cout<<m_name<<"今年"<<m_age<<"岁了，是个无业游民。"<<endl;
}
//派生类Teacher
class Teacher: public People{
public:
    Teacher(char *name, int age, int salary);
    virtual void display();  //声明为虚函数
private:
    int m_salary;
};
Teacher::Teacher(char *name, int age, int salary): People(name, age), m_salary(salary){}
void Teacher::display(){
    cout<<m_name<<"今年"<<m_age<<"岁了，是一名教师，每月有"<<m_salary<<"元的收入。"<<endl;
}
int main(){
    People *p = new People("王志刚", 23);
    p -> display();
    p = new Teacher("赵宏佳", 45, 8200);
    p -> display();
    return 0;
}
//王志刚今年23岁了，是个无业游民。
//赵宏佳今年45岁了，是一名教师，每月有8200元的收入。
```

**借助引用也可以实现多态**：

```c++
int main(){
    People p("王志刚", 23);
    Teacher t("赵宏佳", 45, 8200);
   
    People &rp = p;
    People &rt = t;
   
    rp.display();
    rt.display();
    return 0;
}
//王志刚今年23岁了，是个无业游民。
//赵宏佳今年45岁了，是一名教师，每月有8200元的收入。
```

由于引用类似于常量，只能在定义的同时初始化，并且以后也要从一而终，不能再引用其他数据，所以本例中必须要定义两个引用变量，一个用来引用基类对象，一个用来引用派生类对象。

不过引用不像指针灵活，指针可以随时改变指向，而引用只能指代固定的对象，在多态性方面缺乏表现力，所以以后我们再谈及多态时一般是说指针。

#### 2.虚函数注意事项&构成多态的条件

1. 只需要在虚函数的声明处加上 virtual 关键字，函数定义处可以加也可以不加。
2. 为了方便，你可以只将基类中的函数声明为虚函数，这样所有派生类中具有遮蔽关系的同名函数都将自动成为虚函数。
3. 当在基类中定义了虚函数时，如果派生类没有定义新的函数来遮蔽此函数，那么将使用基类的虚函数。
4.  只有派生类的虚函数覆盖基类的虚函数（函数原型相同）才能构成多态（通过基类[指针](http://c.biancheng.net/c/80/)访问派生类函数）。例如基类虚函数的原型为`virtual void func();`，派生类虚函数的原型为`virtual void func(int);`，那么当基类指针 p 指向派生类对象时，语句`p -> func(100);`**将会出错**，而语句`p -> func();`将调用基类的函数。
5. 构造函数不能是虚函数。对于基类的构造函数，它仅仅是在派生类构造函数中被调用，这种机制不同于继承。也就是说，派生类不继承基类的构造函数，将构造函数声明为虚函数没有什么意义。
6. 析构函数可以声明为虚函数，而且有时候必须要声明为虚函数。

构成多态的条件：

- 必须存在继承关系；
- 继承关系中必须有同名的虚函数，并且它们是覆盖关系（函数原型相同）。
- 存在基类的指针，通过该指针调用虚函数。

#### 3.纯虚函数和抽象类详解

在C++中，可以将虚函数声明为纯虚函数，语法格式为：

```
virtual 返回值类型 函数名 (函数参数) = 0;
```

纯虚函数没有函数体，只有函数声明，在虚函数声明的结尾加上`=0`，表明此函数为纯虚函数。

包含纯虚函数的类称为抽象类（Abstract Class）。之所以说它抽象，是因为它无法实例化，也就是无法创建对象。原因很明显，纯虚函数没有函数体，不是完整的函数，无法调用，也无法为其分配内存空间。

抽象类通常是作为基类，让派生类去实现纯虚函数。派生类必须实现纯虚函数才能被实例化。

**关于纯虚函数的几点说明**：

1) 一个纯虚函数就可以使类成为抽象基类，但是抽象基类中除了包含纯虚函数外，还可以包含其它的成员函数（虚函数或普通函数）和成员变量。

2) 只有类中的虚函数才能被声明为纯虚函数，普通成员函数和顶层函数均不能声明为纯虚函数。

#### 4.typeid运算符

typeid 运算符用来获取一个表达式的类型信息。类型信息对于编程语言非常重要，它描述了数据的各种属性：

- 对于基本类型（int、float 等C++内置类型）的数据，类型信息所包含的内容比较简单，主要是指数据的类型。
- 对于类类型的数据（也就是对象），类型信息是指对象所属的类、所包含的成员、所在的继承关系等。

类型信息是创建数据的模板，数据占用多大内存、能进行什么样的操作、该如何操作等，这些都由它的类型信息决定。

typeid 的操作对象既可以是表达式，也可以是数据类型，下面是它的两种使用方法：

```
typeid( dataType )
typeid( expression )
```

dataType 是数据类型，expression 是表达式，这和 sizeof 运算符非常类似，只不过 sizeof 有时候可以省略括号`( )`，而 typeid 必须带上括号。

typeid 会把获取到的类型信息保存到一个 type_info 类型的对象里面，并返回该对象的常引用；当需要具体的类型信息时，可以通过成员函数来提取。

 type_info 类的几个成员函数：

- name() 用来返回类型的名称。「必要」
- raw_name() 用来返回名字编码（Name Mangling）算法产生的新名称。「VC/VS」
- hash_code() 用来返回当前类型对应的 hash 值。「GCC」
- before(const typeinfo& rhs) cons 判断一个类型是否位于另一个类型的前面，rhs 参数是一个 type_info 对象的引用。但是C++标准并没有规定类型的排列顺序，不同的编译器有不同的排列规则，程序员也可以自定义。 「必要」
- boolean operator== (const type_info& rhs) const; 「必要」
- boolean operator!= (const type_info& rhs) const; 「必要」

判断类型是否相等：

1. 内置类型的比较：

   | 类型比较                         | 结果  |
   | -------------------------------- | ----- |
   | typeid(int) == typeid(int)       | true  |
   | typeid(int) == typeid(char)      | false |
   | typeid(char*) == typeid(char)    | false |
   | typeid(a) == typeid(int) //int a | true  |

   

2. 类的比较：

   即使基类指针赋值为派生类指针，它的类型也依然是基类指针。

---

### 七、运算符重载

#### 1.定义

所谓重载，就是赋予新的含义。函数重载（Function Overloading）可以让一个函数名有多种功能，在不同情况下进行不同的操作。**运算符重载（Operator Overloading）**也是一个道理，同一个运算符可以有不同的功能。

实际上，我们已经在不知不觉中使用了运算符重载。例如，`+`号可以对不同类型（int、float 等）的数据进行加法操作；`<<`既是位移运算符，又可以配合 cout 向控制台输出数据。[C++](http://c.biancheng.net/cplus/) 本身已经对这些运算符进行了重载。

例如定义一个复数类，通过重载+运算符，实现复数的加法运算：

```c++
#include <iostream>
using namespace std;
class complex{
    public:
    	complex(double real, double imag);
    public:
    	complex operator+(const complex &A)const;//声明运算符重载
    	void display() const;
    private:
    	double m_real;
    	double m_imag;
};
complex::complex(double real, double imag):m_real(0.0),m_imag(0.0){}
//实现运算符重载
complex complex::operator+(const complex &A)const{
// ^       ^
// |       |
//返回值  域解析
    complex B;
    B.m_real=this->m_real+A.m_real;
    B.m_imag=this->m_imag+A.m_real;
    return B;
}
```

运算符重载其实就是定义一个函数，在函数体内实现想要的功能，当用到该运算符时，编译器会自动调用这个函数。也就是说，运算符重载是通过函数实现的，它本质上是函数重载。

运算符重载的格式为：

```
返回值类型 operator 运算符名称 (形参表列){
  //TODO:
}
```

`operator`是关键字，专门用于定义重载运算符的函数。我们可以将`operator 运算符名称`这一部分看做函数名，对于上面的代码，函数名就是`operator+`。

上面的例子中，我们在 complex 类中重载了运算符`+`，该重载只对 complex 对象有效。当执行`c3 = c1 + c2;`语句时，编译器检测到`+`号左边（`+`号具有左结合性，所以先检测左边）是一个 complex 对象，就会调用成员函数`operator+()`，也就是转换为下面的形式：

```c++
c3 = c1.operator+(c2);
```

c1 是要调用函数的对象，c2 是函数的实参。

#### 2.在全局范围内重载运算符

运算符重载函数不仅可以作为类的成员函数，还可以作为全局函数。更改上面的代码，在全局范围内重载`+`，实现复数的加法运算：

```c++
#include <iostream>
using namespace std;
class complex{
    public:
    	complex(double real, double imag);
    public:
    	complex operator+(const complex &A);//声明为友元函数
    	void display() const;
    private:
    	double m_real;
    	double m_imag;
};
complex::complex(double real, double imag):m_real(0.0),m_imag(0.0){}
//在全局范围内重载+
complex operator+(const complex &A, const complex &B);//声明
complex operator+(const complex &A, const complex &B){
    complex C;
    C.m_real = A.m_real + B.m_real;
    C.m_imag = A.m_imag + B.m_imag;
    return C;
}
```

运算符重载函数不是 complex 类的成员函数，但是却用到了 complex 类的 private 成员变量，所以必须在 complex 类中将该函数声明为友元函数。

当执行`c3 = c1 + c2;`语句时，编译器检测到`+`号两边都是 complex 对象，就会转换为类似下面的函数调用：

```
c3 = operator+(c1, c2);
```

#### 3.运算符重载时要遵循的规则

1. 并不是所有的运算符都可以重载。能够重载的运算符包括：

   ```c++
   + - * / % ^ & | ~ ! = < > += -= *= /= %= ^= &= |=  << >> <<= >>= == != <= >= && || ++ -- , ->* -> () []  new new[] delete delete[]
   ```

   上述运算符中，`[]`是下标运算符，`()`是函数调用运算符。自增自减运算符的前置和后置形式都可以重载。长度运算符`sizeof`、条件运算符`: ?`、成员选择符`.`和域解析运算符`::`不能被重载。

2. 重载不能改变运算符的优先级和结合性。假设上一节的 complex 类中重载了`+`号和`*`号，并且 c1、c2、c3、c4 都是 complex 类的对象，那么下面的语句：

   ```
   c4 = c1 + c2 * c3;
   ```

   等价于：

   ```
   c4 = c1 + ( c2 * c3 );
   ```

   乘法的优先级仍然高于加法，并且它们仍然是二元运算符。

3. 重载不会改变运算符的用法，原有有几个操作数、操作数在左边还是在右边，这些都不会改变。例如`~`号右边只有一个操作数，`+`号总是出现在两个操作数之间，重载后也必须如此。

4. 运算符重载函数不能有默认的参数，否则就改变了运算符操作数的个数，这显然是错误的。

5. 运算符重载函数既可以作为类的成员函数，也可以作为全局函数。

6. 将运算符重载函数作为类的成员函数时，二元运算符的参数只有一个，一元运算符不需要参数。之所以少一个参数，是因为这个参数是隐含的。

7. 箭头运算符`->`、下标运算符`[ ]`、函数调用运算符`( )`、赋值运算符`=`只能以成员函数的形式重载。

需要注意的是，我们以全局函数的形式重载了 +、-、、/、==、!=，以成员函数的形式重载了 +=、-=、=、/=，而且应该坚持这样做，不能一股脑都写作成员函数或者全局函数。

#### 4.重载>>和<<

C++标准库本身已经对左移运算符`<<`和右移运算符`>>`分别进行了重载，使其能够用于不同数据的输入输出，但是输入输出的对象只能是 C++ 内置的数据类型（例如 bool、int、double 等）和标准库所包含的类类型（例如 string、complex、ofstream、ifstream 等）。

cout 是 ostream 类的对象，cin 是 istream 类的对象。

下面我们以全局函数的形式重载`>>`，使它能够读入两个 double 类型的数据，并分别赋值给复数的实部和虚部：

```c++
istream & operator>>(istream &in, complex &A){ 
	in >> A.m_real >> A.m_imag;    
    return in;
}
```

istream 表示输入流，cin 是 istream 类的对象，只不过这个对象是在标准库中定义的。之所以返回 istream 类对象的引用，是为了能够连续读取复数，让代码书写更加漂亮，例如：

```c++
complex c1, c2;
cin>>c1>>c2;
```

如果不返回引用，那就只能一个一个地读取了：

```c++
complex c1, c2;
cin>>c1;
cin>>c2;
```

另外，运算符重载函数中用到了 complex 类的 private 成员变量，必须在 complex 类中将该函数声明为友元函数：

```c++
friend istream & operator>>(istream & in , complex &a);
```

`>>`运算符可以按照下面的方式使用：

```c++
complex c;
cin>>c;
```

当输入`1.45 2.34↙`后，这两个小数就分别成为对象 c 的实部和虚部了。`cin>> c;`这一语句其实可以理解为：

```c++
operator>>(cin , c);
```

<<同理。

#### 5.重载[]、++和--

C++规定，下标运算符必须以成员函数的形式进行重载。声明格式如下：

```
返回值类型 & operator[](参数);
```

或者

```
const 返回值类型 & operator[] (参数) const;
```

使用第一种声明方式，`[ ]`不仅可以访问元素，还可以修改元素。使用第二种声明方式，`[ ]`只能访问而不能修改元素。在实际开发中，我们应该同时提供以上两种形式，这样做是为了适应 const 对象，因为通过 const 对象只能调用 const 成员函数，如果不提供第二种形式，那么将**无法访问** const 对象的任何元素。

下面我们通过一个具体的例子来演示如何重载`[ ]`。我们知道，有些较老的编译器不支持变长数组，例如 VC6.0、VS2010 等，这有时候会给编程带来不便，下面我们通过自定义的 Array 类来实现变长数组。见Array.cpp。

自增`++`和自减`--`都是一元运算符，它的前置形式和后置形式都可以被重载。请看下面的例子：

```c++
	returnType operator++(int i);  //++i，前置形式声明
    returnType operator++(int j);  //i++，后置形式声明，i、j并非必要
```

#### 6.重载new和delete

内存管理运算符 new、new[]、delete 和 delete[] 也可以进行重载，其重载形式既可以是类的成员函数，也可以是全局函数。一般情况下，内建的内存管理运算符就够用了，只有在需要自己管理内存时才会重载。

以成员函数的形式重载 new 运算符：

```c++
void * className::operator new( size_t size ){
  //TODO:
}
```

以全局函数的形式重载 new 运算符：

```c++
void * operator new( size_t size ){
  //TODO:
}
```

两种重载形式的返回值相同，都是**void ***类型，并且都有一个参数，为`size_t`类型。在重载 new 或 new[] 时，无论是作为成员函数还是作为全局函数，它的第一个参数**必须是 size_t** 类型。size_t 表示的是要分配空间的大小，对于 new[] 的重载函数而言，size_t 则表示所需要分配的所有空间的总和。

```
size_t 在头文件 <cstdio> 中被定义为typedef unsigned int size_t;，也就是无符号整型。
```

同样的，delete 运算符也有两种重载形式。以类的成员函数的形式进行重载：

```c++
void className::operator delete( void *ptr){
  //TODO:
}
```

以全局函数的形式进行重载：

```c++
void operator delete( void *ptr){
  //TODO:
}
```

两种重载形式的返回值都是 void 类型，并且都必须有一个 void 类型的指针作为参数，该指针指向需要释放的内存空间。

如果类中没有定义 new 和 delete 的重载函数，那么会自动调用内建的 new 和 delete 运算符。

#### 8.重载() --强制类型转换运算符

类型强制转换运算符是单目运算符，也可以被重载，但只能重载为成员函数，不能重载为全局函数。经过适当重载后，`(类型名)对象`这个对对象进行强制类型转换的表达式就等价于`对象.operator 类型名()`，即变成对运算符函数的调用。

下面的程序对 double 类型强制转换运算符进行了重载：

```c++
#include <iostream>
using namespace std;
class Complex
{
    double real, imag;
public:
    Complex(double r = 0, double i = 0) :real(r), imag(i) {};
    operator double() { return real; }  //重载强制类型转换运算符 double
};
```

有了对 double 运算符的重载，在本该出现 double 类型的变量或常量的地方，如果出现了一个 Complex 类型的对象，那么该对象的 operator double 成员函数就会被调用，然后取其返回值使用。

```c++
 Complex c(1.2, 3.4);
 cout << (double)c << endl;  //输出 1.2
```

#### 9.运算符重载注意事项

进行运算符重载时，有以下问题需要注意：

- 重载后运算符的含义应该符合原有用法习惯。例如重载`+`运算符，完成的功能就应该类似于做加法，在重载的`+`运算符中做减法是不合适的。此外，重载应尽量保留运算符原有的特性。
- C++ 规定，运算符重载不改变运算符的优先级。
- 以下运算符不能被重载：`.`、`.*`、`::`、`? :`、`sizeof`。
- 重载运算符`()`、`[]`、`->`、或者赋值运算符`=`时，只能将它们重载为成员函数，不能重载为全局函数。


运算符重载的实质是将运算符重载为一个函数，使用运算符的表达式就被解释为对重载函数的调用。

运算符可以重载为全局函数。此时函数的参数个数就是运算符的操作数个数，运算符的操作数就成为函数的实参。

运算符也可以重载为成员函数。此时函数的参数个数就是运算符的操作数个数减一，运算符的操作数有一个成为函数作用的对象，其余的成为函数的实参。

必要时需要重载赋值运算符=，以避免两个对象内部的指针指向同一片存储空间。

运算符可以重载为全局函数，然后声明为类的友元。

<<和>>是在 iostream 中被重载，才成为所谓的“流插入运算符”和“流提取运算符”的。

类型的名字可以作为强制类型转换运算符，也可以被重载为类的成员函数。它能使得对象被自动转换为某种类型。

自增、自减运算符各有两种重载方式，用于区别前置用法和后置用法。

运算符重载不改变运算符的优先级。重载运算符时，应该尽量保留运算符原本的特性。

对于[ ]运算符，一般需要既重载一般形式，又重载常函数形式。

---

### 八、模板和泛型

#### 1.函数模板

 泛型程序设计（generic programming）是一种算法在实现时不指定具体要操作的数据的类型的程序设计方法。所谓“泛型”，指的是算法只要实现一遍，就能适用于多种数据类型。泛型程序设计方法的优势在于能够减少重复代码的编写。

在 C++ 中，模板分为函数模板和类模板两种。熟练的 C++ 程序员，在编写函数时都会考虑能否将其写成函数模板，编写类时都会考虑能否将其写成类模板，以便实现重用。

类型的参数化：数据的类型也可以通过参数来传递，在函数定义时可以不指明具体的数据类型，当发生函数调用时，编译器可以根据传入的实参自动推断数据类型。

```c++
template<typename T> void Swap(T *a, T *b){
    T temp = *a;
    *a = *b;
    *b = temp;
}
```

`template`是定义函数模板的关键字，它后面紧跟尖括号`<>`，尖括号包围的是类型参数（也可以说是虚拟的类型，或者说是类型占位符）。`typename`是另外一个关键字，用来声明具体的类型参数，这里的类型参数就是`T`。从整体上看，`template<typename T>`被称为模板头。

模板头中包含的类型参数可以用在函数定义的各个位置，包括返回值、形参列表和函数体；本例我们在形参列表和函数体中使用了类型参数`T`。

类型参数的命名规则跟其他标识符的命名规则一样，不过使用 T、T1、T2、Type 等已经成为了一种惯例。

下面我们来总结一下定义模板函数的语法：

```
template <typename 类型参数1 , typename 类型参数2 , ...> 返回值类型  函数名(形参列表){
  //在函数体中可以使用类型参数
}
```

类型参数可以有多个，它们之间以逗号`,`分隔。类型参数列表以`< >`包围，形式参数列表以`( )`包围。

`typename`关键字也可以使用`class`关键字替代，它们没有任何区别。

#### 2.类模板

除了支持函数模板，还支持**类模板（Class Template）**。函数模板中定义的类型参数可以用在函数声明和函数定义中，类模板中定义的类型参数可以用在类声明和类实现中。类模板的目的同样是将数据的类型参数化。

声明类模板的语法为：

```C++
template<typename 类型参数1 , typename 类型参数2 , …> //模板头
class 类名{
  //TODO:
};
```

类模板和函数模板都是以 template 开头（当然也可以使用 class，目前来讲它们没有任何区别），后跟类型参数；类型参数不能为空，多个类型参数用逗号隔开。

一但声明了类模板，就可以将类型参数用于类的成员函数和成员变量了。换句话说，原来使用 int、float、char 等内置类型的地方，都可以用类型参数来代替。

需要在类外定义成员函数。在类外定义成员函数时仍然需要带上模板头，此时类名后要紧跟<>，例如

```C++
template<typename T1, typename T2>  //模板头
T1 Point<T1, T2>::getX() const /*函数头*/ {
    return m_x;
}
```

使用类模板创建对象时，需要指明具体的数据类型。请看下面的代码：

```C++
Point<int, int> p1(10, 20);
Point<int, float> p2(10, 15.5);
Point<float, char*> p3(12.4, "东经180度");
```

除了对象变量，我们也可以使用对象指针的方式来实例化：

```C++
Point<float, float> *p1 = new Point<float, float>(10.6, 109.3);
Point<char*, char*> *p = new Point<char*, char*>("东经180度", "北纬210度");
```

模板所支持的类型是宽泛的，没有限制的，我们可以使用任意类型来替换，这种编程方式称为泛型编程（Generic Programming）。

C++ 模板也是被迫推出的，最直接的动力来源于对数据结构的封装。

---

### 九、异常处理

程序的错误大致可以分为三种，分别是语法错误、逻辑错误和运行时错误：

1. 语法错误在编译和链接阶段就能发现，只有 100% 符合语法规则的代码才能生成可执行程序。语法错误是最容易发现、最容易定位、最容易排除的错误，程序员最不需要担心的就是这种错误。

2. 逻辑错误是说我们编写的代码思路有问题，不能够达到最终的目标，这种错误可以通过调试来解决。

3. 运行时错误是指程序在运行期间发生的错误，例如除数为 0、内存分配失败、数组越界、文件不存在等。C++异常（Exception）机制就是为解决运行时错误而引入的。

#### 1.捕获异常

我们可以借助 C++ 异常机制来捕获上面的异常，避免程序崩溃。捕获异常的语法为：

```C++
try{
    // 可能抛出异常的语句
}catch(exceptionType variable){
    // 处理异常的语句
}
```

`try`和`catch`都是 C++ 中的关键字，后跟语句块，不能省略`{ }`。try 中包含可能会抛出异常的语句，一旦有异常抛出就会被后面的 catch 捕获。从 try 的意思可以看出，它只是“检测”语句块有没有异常，如果没有发生异常，它就“检测”不到。catch 是“抓住”的意思，用来捕获并处理 try 检测到的异常；如果 try 语句块没有检测到异常（没有异常抛出），那么就不会执行 catch 中的语句。

这就好比，catch 告诉 try：你去检测一下程序有没有错误，有错误的话就告诉我，我来处理，没有的话就不要理我！

```c++
	string str = "http://c.biancheng.net";
  
    try{
        char ch1 = str[100];
        cout<<ch1<<endl;
    }catch(exception e){
        cout<<"[1]out of bound!"<<endl;
    }
    try{
        char ch2 = str.at(100);
        cout<<ch2<<endl;
    }catch(exception &e){  //exception类位于<exception>头文件中
        cout<<"[2]out of bound!"<<endl;
    }
/*输出：
(
[2]out of bound!
*/
```

可以看出，第一个 try 没有捕获到异常，输出了一个没有意义的字符（垃圾值）。因为`[ ]`不会检查下标越界，不会抛出异常，所以即使有错误，try 也检测不到。换句话说，发生异常时必须将异常明确地抛出，try 才能检测到；如果不抛出来，即使有异常 try 也检测不到。所谓抛出异常，就是明确地告诉程序发生了什么错误。

第二个 try 检测到了异常，并交给 catch 处理，执行 catch 中的语句。需要说明的是，异常一旦抛出，会立刻被 try 检测到，并且不会再执行异常点（异常发生位置）后面的语句。本例中抛出异常的位置是at() 函数，它后面的 cout 语句就不会再被执行，所以看不到它的输出。

说得直接一点，检测到异常后程序的执行流会发生跳转，从异常点跳转到 catch 所在的位置，位于异常点之后的、并且在当前 try 块内的语句就都不会再执行了；即使 catch 语句成功地处理了错误，程序的执行流也不会再回退到异常点，所以这些语句永远都没有执行的机会了。

执行完 catch 块所包含的代码后，程序会继续执行 catch 块后面的代码，就恢复了正常的执行流。

#### 2.发生异常的位置

异常可以发生在当前的 try 块中，也可以发生在 try 块所调用的某个函数中，或者是所调用的函数又调用了另外的一个函数，这个另外的函数中发生了异常。这些异常，都可以被 try 检测到。

1. 直接发生在`try`块内的异常：

   ```C++
    try{
           throw "Unknown Exception";  //抛出异常
           cout<<"This statement will not be executed."<<endl;
       }catch(const char* &e){
           cout<<e<<endl;
       }
   //结果： Unknown Exception
   ```

   `throw`关键字用来抛出一个异常，这个异常会被 try 检测到，进而被 catch 捕获。

2. `try`中调用的函数发生异常：

   ```C++
   void func(){
       throw "Unknown Exception";  //抛出异常
       cout<<"[1]This statement will not be executed."<<endl;
   }
   int main(){
       try{
           func();
           cout<<"[2]This statement will not be executed."<<endl;
       }catch(const char* &e){
           cout<<e<<endl;
       }
       return 0;
   }
   //结果： Unknown Exception
   ```

3. try 块中调用了某个函数，该函数又调用了另外的一个函数，这个另外的函数抛出了异常：

   ```C++
   void func_inner(){
       throw "Unknown Exception";  //抛出异常
       cout<<"[1]This statement will not be executed."<<endl;
   }
   void func_outer(){
       func_inner();
       cout<<"[2]This statement will not be executed."<<endl;
   }
   int main(){
       try{
           func_outer();
           cout<<"[3]This statement will not be executed."<<endl;
       }catch(const char* &e){
           cout<<e<<endl;
       }
       return 0;
   }
   //结果： Unknown Exception
   ```

#### 4.异常类型&多级catch匹配

`exceptionType`是异常类型，它指明了当前的 catch 可以处理什么类型的异常；`variable`是一个变量，用来接收异常信息。当程序抛出异常时，会创建一份数据，这份数据包含了错误信息，程序员可以根据这些信息来判断到底出了什么问题，接下来怎么处理。

异常既然是一份数据，那么就应该有数据类型。C++ 规定，异常类型可以是 int、char、float、bool 等基本类型，也可以是指针、数组、字符串、结构体、类等聚合类型。C++ 语言本身以及标准库中的函数抛出的异常，都是 exception 类或其子类的异常。也就是说，抛出异常时，会创建一个 exception 类或其子类的对象。（例如上例中的char *  & 字符指针引用）

`exceptionType variable`和函数的形参非常类似，当异常发生后，会将异常数据传递给 variable 这个变量，这和函数传参的过程类似。当然，只有跟 exceptionType 类型匹配的异常数据才会被传递给 variable，否则 catch 不会接收这份异常数据，也不会执行 catch 块中的语句。换句话说，catch 不会处理当前的异常。

我们可以将 catch 看做一个没有返回值的函数，当异常发生后 catch 会被调用，并且会接收实参，即异常数据。

但是 catch 和真正的函数调用又有区别：

- 真正的函数调用，形参和实参的类型必须要匹配，或者可以自动转换，否则在编译阶段就报错了。
- 而对于 catch，异常是在运行阶段产生的，它可以是任何类型，没法提前预测，所以不能在编译阶段判断类型是否正确，只能等到程序运行后，真的抛出异常了，再将异常类型和 catch 能处理的类型进行匹配，匹配成功的话就“调用”当前的 catch，否则就忽略当前的 catch。

**多级catch**：

```C++
 	try{
        throw Derived();  //抛出自己的异常类型，实际上是创建一个Derived类型的匿名对象
        cout<<"This statement will not be executed."<<endl;
    }catch(int){
        cout<<"Exception type: int"<<endl;
    }catch(char *){
        cout<<"Exception type: cahr *"<<endl;
    }catch(Base){  //匹配成功（向上转型）
        cout<<"Exception type: Base"<<endl;
    }catch(Derived){
        cout<<"Exception type: Derived"<<endl;
    }
//输出：Exception type: Base
```

当异常发生时，程序会按照从上到下的顺序，将异常类型和 catch 所能接收的类型逐个匹配。一旦找到类型匹配的 catch 就停止检索，并将异常交给当前的 catch 处理（其他的 catch 不会被执行）。如果最终也没有找到匹配的 catch，就只能交给系统处理，终止程序的运行。

**类型转换**

C/C++ 中存在多种多样的类型转换，以普通函数（非模板函数）为例，发生函数调用时，如果实参和形参的类型不是严格匹配，那么会将实参的类型进行适当的转换，以适应形参的类型，这些转换包括：

- 算数转换：例如 int 转换为 float，char 转换为 int，double 转换为 int 等。
- 向上转型：也就是派生类向基类的转换。
- const 转换：也即将非 const 类型转换为 const 类型，例如将 char * 转换为 const char *。
- 数组或函数指针转换：如果函数形参不是引用类型，那么数组名会转换为数组指针，函数名也会转换为函数指针。
- 用户自定的类型转换。

catch 在匹配异常类型的过程中，也会进行类型转换，但是这种转换受到了更多的限制，仅能进行「向上转型」、「const 转换」和「数组或函数指针转换」，其他的都不能应用于 catch。

#### 5.throw

在 C++ 中，我们使用 throw 关键字来显式地抛出异常，它的用法为：

```C++
throw exceptionData;
```

exceptionData 是“异常数据”的意思，它可以包含任意的信息，完全有程序员决定。exceptionData 可以是 int、float、bool 等基本类型，也可以是指针、数组、字符串、结构体、类等聚合类型。

给出一个动态数组的例子，见Array2.cpp

throw 关键字除了可以用在函数体中抛出异常，还可以用在函数头和函数体之间，指明当前函数能够抛出的异常类型，这称为异常规范（Exception specification），有些教程也称为异常指示符或异常列表。请看下面的例子：

```C++
double func (char param) throw (int);
```

这条语句声明了一个名为 func 的函数，它的返回值类型为 double，有一个 char 类型的参数，并且只能抛出 int 类型的异常。如果抛出其他类型的异常，try 将无法捕获，只能终止程序。

如果函数会抛出多种类型的异常，那么可以用逗号隔开：

```C++
double func (char param) throw (int, char, exception);
```

如果函数不会抛出任何异常，那么`( )`中什么也不写：

```C++
double func (char param) throw ();
```

如此，func() 函数就不能抛出任何类型的异常了，即使抛出了，try 也检测不到。

1. 虚函数中的异常规范：C++ 规定，派生类虚函数的异常规范必须与基类虚函数的异常规范一样严格，或者更严格。只有这样，当通过基类指针（或者引用）调用派生类虚函数时，才能保证不违背基类成员函数的异常规范。
2. 异常规范与函数声明：C++ 规定，异常规范在函数声明和函数定义中必须同时指明，并且要严格保持一致，不能更加严格或者更加宽松。

**请抛弃异常规范，不要再使用它**

例如，func_outer() 函数可能不会引发异常，但它调用了另外一个函数 func_inner()，这个函数可能会引发异常。再如，您编写的函数调用了老式的库函数，此时不会引发异常，但是库更新以后这个函数却引发了异常。总之，异常规范的初衷实现起来有点困难，所以大家达成的一致意见是，最好不要使用异常规范。

#### 6.exception类：标准异常的基类

C++语言本身或者标准库抛出的异常都是 exception 的子类，称为标准异常（Standard Exception）。你可以通过下面的语句来捕获所有的标准异常：

```c++
try{    //可能抛出异常的语句
}catch(exception &e){    
    //处理异常的语句
}
```

之所以使用引用，是为了提高效率。如果不使用引用，就要经历一次对象拷贝（要调用拷贝构造函数）的过程。

exception 类位于 <exception> 头文件中，它被声明为：

```c++
class exception{
public:
    exception () throw();  //构造函数
    exception (const exception&) throw();  //拷贝构造函数
    exception& operator= (const exception&) throw();  //运算符重载
    virtual ~exception() throw();  //虚析构函数
    virtual const char* what() const throw();  //虚函数
}
```

这里需要说明的是 what() 函数。what() 函数返回一个能识别异常的字符串，正如它的名字“what”一样，可以粗略地告诉你这是什么异常。不过C++标准并没有规定这个字符串的格式，各个编译器的实现也不同，所以 what() 的返回值仅供参考。